--- FILE: ./userService.js ---
import axios from 'axios';

const API_URL = 'http://localhost:1337/api';

const getAuthHeader = () => ({
  headers: {
    'Authorization': `Bearer ${localStorage.getItem('token')}`
  }
});

const userService = {
  // Get all users with optional role filter
  getAllUsers: async (role = null) => {
    try {
      const params = role 
        ? { 'filters[userRole][$eq]': role }
        : {};
      
      const response = await axios.get(`${API_URL}/users`, {
        ...getAuthHeader(),
        params
      });
      return response.data;
    } catch (error) {
      throw new Error(error.response?.data?.error?.message || 'Failed to fetch users');
    }
  },

  // Get all teachers
  getAllTeachers: async () => {
    return userService.getAllUsers('teacher');
  },

  // Get all students
  getAllStudents: async () => {
    return userService.getAllUsers('student');
  },

  // Get user by id
  getUserById: async (userId) => {
    try {
      const response = await axios.get(`${API_URL}/users/${userId}`, getAuthHeader());
      return response.data;
    } catch (error) {
      throw new Error(error.response?.data?.error?.message || 'Failed to fetch user');
    }
  }
};

export default userService;

--- FILE: ./gradeService.js ---
import axios from 'axios';

const API_URL = 'http://localhost:1337/api';

const getAuthHeader = () => ({
  headers: {
    'Authorization': `Bearer ${localStorage.getItem('token')}`
  }
});

const gradeService = {
  // Get all grades with optional filters
  getAllGrades: async (params = {}) => {
    try {
      const response = await axios.get(`${API_URL}/grades`, {
        ...getAuthHeader(),
        params
      });
      return response.data.data;
    } catch (error) {
      throw new Error(error.response?.data?.error?.message || 'Failed to fetch grades');
    }
  },

  // Get single grade by documentId
  getGradeById: async (documentId) => {
    try {
      const response = await axios.get(`${API_URL}/grades/${documentId}`, getAuthHeader());
      return response.data.data;
    } catch (error) {
      throw new Error(error.response?.data?.error?.message || 'Failed to fetch grade');
    }
  },

  // Create a new grade
  createGrade: async (gradeData) => {
    try {
      const response = await axios.post(
        `${API_URL}/grades`,
        { data: gradeData },
        getAuthHeader()
      );
      return response.data.data;
    } catch (error) {
      throw new Error(error.response?.data?.error?.message || 'Failed to create grade');
    }
  },

  // Update grade by documentId
  updateGrade: async (documentId, gradeData) => {
    try {
      const response = await axios.put(
        `${API_URL}/grades/${documentId}`,
        { data: gradeData },
        getAuthHeader()
      );
      return response.data.data;
    } catch (error) {
      throw new Error(error.response?.data?.error?.message || 'Failed to update grade');
    }
  },

  // Delete grade by documentId
  deleteGrade: async (documentId) => {
    try {
      await axios.delete(`${API_URL}/grades/${documentId}`, getAuthHeader());
      return true;
    } catch (error) {
      throw new Error(error.response?.data?.error?.message || 'Failed to delete grade');
    }
  }
};

export default gradeService;

--- FILE: ./subjectService.js ---
import API from '../api';

/**
 * Subject Service for Strapi v5 API
 * Handles CRUD operations for subjects within courses
 */

const subjectService = {
  /**
   * Get all subjects with optional filters
   * @param {Object} params - Query parameters (page, pageSize, filters, or custom params)
   * @returns {Promise} - Subjects list with metadata
   */
  async getAllSubjects(params = {}) {
    try {
      // If custom filter params are passed (like filters[course][id][$eq]), use them directly
      if (Object.keys(params).some(key => key.startsWith('filters['))) {
        const response = await API.get('/api/subjects', { params });
        return response.data.data; // Return the data array from Strapi v5 response
      }
      
      // Otherwise use legacy format
      const { page = 1, pageSize = 100, courseId = null } = params;
      
      let queryString = `?populate=*&pagination[page]=${page}&pagination[pageSize]=${pageSize}`;
      
      // Filter by course if provided
      if (courseId) {
        queryString += `&filters[course][documentId][$eq]=${courseId}`;
      }
      
      const response = await API.get(`/api/subjects${queryString}`);
      return response.data.data; // Return the data array from Strapi v5 response
    } catch (error) {
      console.error('Error fetching subjects:', error);
      throw error;
    }
  },

  /**
   * Get subjects for a specific course
   * @param {string} courseDocumentId - Course document ID
   * @returns {Promise} - Subjects list
   */
  async getSubjectsByCourse(courseDocumentId) {
    try {
      const response = await API.get(
        `/api/subjects?filters[course][documentId][$eq]=${courseDocumentId}&populate=*`
      );
      return response.data;
    } catch (error) {
      console.error('Error fetching course subjects:', error);
      throw error;
    }
  },

  /**
   * Get single subject by documentId
   * @param {string} documentId - Subject document ID
   * @returns {Promise} - Subject data
   */
  async getSubjectById(documentId) {
    try {
      const response = await API.get(`/api/subjects/${documentId}?populate=*`);
      return response.data;
    } catch (error) {
      console.error('Error fetching subject:', error);
      throw error;
    }
  },

  /**
   * Create new subject
   * @param {Object} subjectData - Subject data
   * @returns {Promise} - Created subject
   */
  async createSubject(subjectData) {
    try {
      const response = await API.post('/api/subjects', {
        data: subjectData
      });
      return response.data;
    } catch (error) {
      console.error('Error creating subject:', error);
      throw error;
    }
  },

  /**
   * Update subject by documentId
   * @param {string} documentId - Subject document ID
   * @param {Object} subjectData - Updated subject data
   * @returns {Promise} - Updated subject
   */
  async updateSubject(documentId, subjectData) {
    try {
      const response = await API.put(`/api/subjects/${documentId}`, {
        data: subjectData
      });
      return response.data;
    } catch (error) {
      console.error('Error updating subject:', error);
      throw error;
    }
  },

  /**
   * Delete subject by documentId
   * @param {string} documentId - Subject document ID
   * @returns {Promise} - Deleted subject
   */
  async deleteSubject(documentId) {
    try {
      const response = await API.delete(`/api/subjects/${documentId}`);
      return response.data;
    } catch (error) {
      console.error('Error deleting subject:', error);
      throw error;
    }
  },

  /**
   * Upload subject cover icon
   * @param {File} file - Image file
   * @returns {Promise} - Uploaded file data
   */
  async uploadCoverIcon(file) {
    try {
      const formData = new FormData();
      formData.append('files', file);

      const response = await API.post('/api/upload', formData, {
        headers: {
          'Content-Type': 'multipart/form-data',
        },
      });
      return response.data;
    } catch (error) {
      console.error('Error uploading cover icon:', error);
      throw error;
    }
  }
};

export default subjectService;

--- FILE: ./courseService.js ---
import API from '../api';

/**
 * Course Service for Strapi v5 API
 * Handles CRUD operations using documentId
 */

const courseService = {
  /**
   * Get all courses with pagination
   * @param {Object} params - Query parameters (page, pageSize, filters, sort)
   * @returns {Promise} - Courses list with metadata
   */
  async getAllCourses(params = {}) {
    try {
      const { page = 1, pageSize = 25, filters = {}, sort = '' } = params;
      
      let queryString = `?populate=*&pagination[page]=${page}&pagination[pageSize]=${pageSize}`;
      
      // Add filters if provided
      if (Object.keys(filters).length > 0) {
        Object.keys(filters).forEach(key => {
          queryString += `&filters[${key}][$eq]=${filters[key]}`;
        });
      }
      
      // Add sorting if provided
      if (sort) {
        queryString += `&sort=${sort}`;
      }
      
      const response = await API.get(`/api/courses${queryString}`);
      return response.data;
    } catch (error) {
      console.error('Error fetching courses:', error);
      throw error;
    }
  },

  /**
   * Get single course by documentId
   * @param {string} documentId - Course document ID
   * @returns {Promise} - Course data
   */
  async getCourseById(documentId) {
    try {
      const response = await API.get(`/api/courses/${documentId}?populate=*`);
      return response.data;
    } catch (error) {
      console.error('Error fetching course:', error);
      throw error;
    }
  },

  /**
   * Create new course
   * @param {Object} courseData - Course data
   * @returns {Promise} - Created course
   */
  async createCourse(courseData) {
    try {
      const response = await API.post('/api/courses', {
        data: courseData
      });
      return response.data;
    } catch (error) {
      console.error('Error creating course:', error);
      throw error;
    }
  },

  /**
   * Update course by documentId
   * @param {string} documentId - Course document ID
   * @param {Object} courseData - Updated course data
   * @returns {Promise} - Updated course
   */
  async updateCourse(documentId, courseData) {
    try {
      const response = await API.put(`/api/courses/${documentId}`, {
        data: courseData
      });
      return response.data;
    } catch (error) {
      console.error('Error updating course:', error);
      throw error;
    }
  },

  /**
   * Delete course by documentId
   * @param {string} documentId - Course document ID
   * @returns {Promise} - Deleted course
   */
  async deleteCourse(documentId) {
    try {
      const response = await API.delete(`/api/courses/${documentId}`);
      return response.data;
    } catch (error) {
      console.error('Error deleting course:', error);
      throw error;
    }
  },

  /**
   * Upload course cover icon
   * @param {File} file - Image file
   * @returns {Promise} - Uploaded file data
   */
  async uploadCoverIcon(file) {
    try {
      const formData = new FormData();
      formData.append('files', file);

      const response = await API.post('/api/upload', formData, {
        headers: {
          'Content-Type': 'multipart/form-data',
        },
      });
      return response.data;
    } catch (error) {
      console.error('Error uploading cover icon:', error);
      throw error;
    }
  },

  /**
   * Parse description rich text from Strapi format
   * @param {Array} description - Strapi rich text format
   * @returns {string} - Plain text
   */
  parseDescription(description) {
    if (!description || !Array.isArray(description)) return '';
    
    return description
      .map(block => {
        if (block.children) {
          return block.children
            .map(child => child.text || '')
            .join(' ');
        }
        return '';
      })
      .join('\n');
  },

  /**
   * Convert plain text to Strapi rich text format
   * @param {string} text - Plain text
   * @returns {Array} - Strapi rich text format
   */
  formatDescription(text) {
    if (!text) return [];
    
    return [
      {
        type: 'paragraph',
        children: [
          {
            type: 'text',
            text: text
          }
        ]
      }
    ];
  }
};

export default courseService;

--- FILE: ./questionService.js ---
import API from '../api';

const questionService = {
  // Get all questions
  getAllQuestions: async (filters = {}) => {
    const params = new URLSearchParams();
    
    if (filters.subject) params.append('filters[subject][id][$eq]', filters.subject);
    if (filters.course) params.append('filters[course][id][$eq]', filters.course);
    if (filters.questionType) params.append('filters[questionType][$eq]', filters.questionType);
    if (filters.difficultyLevel) params.append('filters[difficultyLevel][$eq]', filters.difficultyLevel);
    
    params.append('populate', '*');
    
    const response = await API.get(`/api/questions?${params.toString()}`);
    return response.data;
  },

  // Get single question
  getQuestion: async (id) => {
    const response = await API.get(`/api/questions/${id}?populate=*`);
    return response.data;
  },

  // Create question
  createQuestion: async (questionData) => {
    const response = await API.post('/api/questions', {
      data: questionData
    });
    return response.data;
  },

  // Update question
  updateQuestion: async (id, questionData) => {
    const response = await API.put(`/api/questions/${id}`, {
      data: questionData
    });
    return response.data;
  },

  // Delete question
  deleteQuestion: async (id) => {
    const response = await API.delete(`/api/questions/${id}`);
    return response.data;
  },

  // Get questions by subject
  getQuestionsBySubject: async (subjectId) => {
    const response = await API.get(`/api/questions?filters[subject][id][$eq]=${subjectId}&populate=*`);
    return response.data;
  },

  // Get questions by course
  getQuestionsByCourse: async (courseId) => {
    const response = await API.get(`/api/questions?filters[course][id][$eq]=${courseId}&populate=*`);
    return response.data;
  }
};

export default questionService;

--- FILE: ./enrolmentService.js ---
import axios from 'axios';

const API_URL = 'http://localhost:1337/api';

const getAuthHeader = () => ({
  headers: {
    'Authorization': `Bearer ${localStorage.getItem('token')}`
  }
});

const enrolmentService = {
  // Get all enrolments with populated data
  getAllEnrolments: async (params = {}) => {
    try {
      const response = await axios.get(`${API_URL}/enrolments`, {
        ...getAuthHeader(),
        params: {
          populate: '*',
          ...params
        }
      });
      return response.data.data;
    } catch (error) {
      throw new Error(error.response?.data?.error?.message || 'Failed to fetch enrolments');
    }
  },

  // Get enrolment by documentId
  getEnrolmentById: async (documentId) => {
    try {
      const response = await axios.get(`${API_URL}/enrolments/${documentId}?populate=*`, getAuthHeader());
      return response.data.data;
    } catch (error) {
      throw new Error(error.response?.data?.error?.message || 'Failed to fetch enrolment');
    }
  },

  // Get enrolments by course
  getEnrolmentsByCourse: async (courseId) => {
    try {
      const response = await axios.get(`${API_URL}/enrolments`, {
        ...getAuthHeader(),
        params: {
          'filters[course][id][$eq]': courseId,
          populate: '*'
        }
      });
      return response.data.data;
    } catch (error) {
      throw new Error(error.response?.data?.error?.message || 'Failed to fetch course enrolments');
    }
  },

  // Create new enrolment
  createEnrolment: async (enrolmentData) => {
    try {
      const response = await axios.post(
        `${API_URL}/enrolments`,
        { data: enrolmentData },
        getAuthHeader()
      );
      return response.data.data;
    } catch (error) {
      throw new Error(error.response?.data?.error?.message || 'Failed to create enrolment');
    }
  },

  // Update enrolment by documentId
  updateEnrolment: async (documentId, enrolmentData) => {
    try {
      const response = await axios.put(
        `${API_URL}/enrolments/${documentId}`,
        { data: enrolmentData },
        getAuthHeader()
      );
      return response.data.data;
    } catch (error) {
      throw new Error(error.response?.data?.error?.message || 'Failed to update enrolment');
    }
  },

  // Assign teachers to course enrolment
  assignTeachers: async (documentId, teacherIds) => {
    try {
      const response = await axios.put(
        `${API_URL}/enrolments/${documentId}`,
        { 
          data: { 
            teachers: teacherIds 
          } 
        },
        getAuthHeader()
      );
      return response.data.data;
    } catch (error) {
      throw new Error(error.response?.data?.error?.message || 'Failed to assign teachers');
    }
  },

  // Assign students to course enrolment
  assignStudents: async (documentId, studentIds) => {
    try {
      const response = await axios.put(
        `${API_URL}/enrolments/${documentId}`,
        { 
          data: { 
            students: studentIds 
          } 
        },
        getAuthHeader()
      );
      return response.data.data;
    } catch (error) {
      throw new Error(error.response?.data?.error?.message || 'Failed to assign students');
    }
  },

  // Assign both teachers and students
  assignUsersToEnrolment: async (documentId, teacherIds, studentIds) => {
    try {
      const response = await axios.put(
        `${API_URL}/enrolments/${documentId}`,
        { 
          data: { 
            teachers: teacherIds,
            students: studentIds
          } 
        },
        getAuthHeader()
      );
      return response.data.data;
    } catch (error) {
      throw new Error(error.response?.data?.error?.message || 'Failed to assign users');
    }
  },

  // Delete enrolment by documentId
  deleteEnrolment: async (documentId) => {
    try {
      await axios.delete(`${API_URL}/enrolments/${documentId}`, getAuthHeader());
      return true;
    } catch (error) {
      throw new Error(error.response?.data?.error?.message || 'Failed to delete enrolment');
    }
  }
};

export default enrolmentService;

--- FILE: ./contentService.js ---
import axios from 'axios';

const API_URL = 'http://localhost:1337/api';

const getAuthHeader = () => ({
  headers: {
    'Authorization': `Bearer ${localStorage.getItem('token')}`
  }
});

const contentService = {
  // Get all contents with optional filters
  getAllContents: async (params = {}) => {
    try {
      const response = await axios.get(`${API_URL}/contents`, {
        ...getAuthHeader(),
        params: {
          populate: '*',
          ...params
        }
      });
      return response.data.data;
    } catch (error) {
      throw new Error(error.response?.data?.error?.message || 'Failed to fetch contents');
    }
  },

  // Get content by documentId
  getContentById: async (documentId) => {
    try {
      const response = await axios.get(`${API_URL}/contents/${documentId}?populate=*`, getAuthHeader());
      return response.data.data;
    } catch (error) {
      throw new Error(error.response?.data?.error?.message || 'Failed to fetch content');
    }
  },

  // Get contents by subject
  getContentsBySubject: async (subjectId) => {
    try {
      const response = await axios.get(`${API_URL}/contents`, {
        ...getAuthHeader(),
        params: {
          'filters[subject][id][$eq]': subjectId,
          populate: '*'
        }
      });
      return response.data.data;
    } catch (error) {
      throw new Error(error.response?.data?.error?.message || 'Failed to fetch subject contents');
    }
  },

  // Get contents by teacher
  getContentsByTeacher: async (teacherId) => {
    try {
      const response = await axios.get(`${API_URL}/contents`, {
        ...getAuthHeader(),
        params: {
          'filters[teacher][id][$eq]': teacherId,
          populate: '*'
        }
      });
      return response.data.data;
    } catch (error) {
      throw new Error(error.response?.data?.error?.message || 'Failed to fetch teacher contents');
    }
  },

  // Create new content
  createContent: async (contentData) => {
    try {
      const response = await axios.post(
        `${API_URL}/contents`,
        { data: contentData },
        getAuthHeader()
      );
      return response.data.data;
    } catch (error) {
      throw new Error(error.response?.data?.error?.message || 'Failed to create content');
    }
  },

  // Update content by documentId
  updateContent: async (documentId, contentData) => {
    try {
      const response = await axios.put(
        `${API_URL}/contents/${documentId}`,
        { data: contentData },
        getAuthHeader()
      );
      return response.data.data;
    } catch (error) {
      throw new Error(error.response?.data?.error?.message || 'Failed to update content');
    }
  },

  // Delete content by documentId
  deleteContent: async (documentId) => {
    try {
      await axios.delete(`${API_URL}/contents/${documentId}`, getAuthHeader());
      return true;
    } catch (error) {
      throw new Error(error.response?.data?.error?.message || 'Failed to delete content');
    }
  },

  // Upload content attachment/media
  uploadMedia: async (files) => {
    try {
      const formData = new FormData();
      
      if (Array.isArray(files)) {
        files.forEach(file => formData.append('files', file));
      } else {
        formData.append('files', files);
      }

      const response = await axios.post(`${API_URL}/upload`, formData, {
        headers: {
          'Authorization': `Bearer ${localStorage.getItem('token')}`,
          'Content-Type': 'multipart/form-data',
        },
      });
      return response.data;
    } catch (error) {
      throw new Error(error.response?.data?.error?.message || 'Failed to upload media');
    }
  }
};

export default contentService;

--- FILE: ./examService.js ---
import API from '../api';

const examService = {
  // Get all exams
  getAllExams: async (filters = {}) => {
    const params = new URLSearchParams();
    
    if (filters.subject) params.append('filters[subject][id][$eq]', filters.subject);
    if (filters.course) params.append('filters[course][id][$eq]', filters.course);
    if (filters.examType) params.append('filters[examType][$eq]', filters.examType);
    
    // Populate questions
    params.append('populate[questions]', '*');
    
    // Populate course with specific fields only (avoid media fields)
    params.append('populate[course][fields][0]', 'id');
    params.append('populate[course][fields][1]', 'name');
    params.append('populate[course][fields][2]', 'subtitle');
    params.append('populate[course][fields][3]', 'description');
    
    // Populate subject with specific fields only
    params.append('populate[subject][fields][0]', 'id');
    params.append('populate[subject][fields][1]', 'name');
    params.append('populate[subject][fields][2]', 'subtitle');
    params.append('populate[subject][fields][3]', 'description');
    
    // Populate exam attempts
    params.append('populate[examAttempts]', '*');
    
    const response = await API.get(`/api/exams?${params.toString()}`);
    return response.data;
  },

  // Get single exam
  getExam: async (id) => {
    const params = new URLSearchParams();
    
    // Populate questions
    params.append('populate[questions]', '*');
    
    // Populate course with specific fields
    params.append('populate[course][fields][0]', 'id');
    params.append('populate[course][fields][1]', 'name');
    params.append('populate[course][fields][2]', 'subtitle');
    params.append('populate[course][fields][3]', 'description');
    
    // Populate subject with specific fields
    params.append('populate[subject][fields][0]', 'id');
    params.append('populate[subject][fields][1]', 'name');
    params.append('populate[subject][fields][2]', 'subtitle');
    params.append('populate[subject][fields][3]', 'description');
    
    // Populate exam attempts
    params.append('populate[examAttempts]', '*');
    
    const response = await API.get(`/api/exams/${id}?${params.toString()}`);
    return response.data;
  },

  // Create exam
  createExam: async (examData) => {
    const response = await API.post('/api/exams', {
      data: examData
    });
    return response.data;
  },

  // Update exam
  updateExam: async (id, examData) => {
    const response = await API.put(`/api/exams/${id}`, {
      data: examData
    });
    return response.data;
  },

  // Delete exam
  deleteExam: async (id) => {
    const response = await API.delete(`/api/exams/${id}`);
    return response.data;
  },

  // Get exams by course
  getExamsByCourse: async (courseId) => {
    const params = new URLSearchParams();
    params.append('filters[course][id][$eq]', courseId);
    params.append('populate[questions]', '*');
    params.append('populate[course][fields][0]', 'id');
    params.append('populate[course][fields][1]', 'name');
    params.append('populate[subject][fields][0]', 'id');
    params.append('populate[subject][fields][1]', 'name');
    
    const response = await API.get(`/api/exams?${params.toString()}`);
    return response.data;
  },

  // Get exams by subject
  getExamsBySubject: async (subjectId) => {
    const params = new URLSearchParams();
    params.append('filters[subject][id][$eq]', subjectId);
    params.append('populate[questions]', '*');
    params.append('populate[course][fields][0]', 'id');
    params.append('populate[course][fields][1]', 'name');
    params.append('populate[subject][fields][0]', 'id');
    params.append('populate[subject][fields][1]', 'name');
    
    const response = await API.get(`/api/exams?${params.toString()}`);
    return response.data;
  },

  // Get exam attempts for an exam
  getExamAttempts: async (examId) => {
    const params = new URLSearchParams();
    params.append('filters[exam][id][$eq]', examId);
    params.append('populate[student][fields][0]', 'id');
    params.append('populate[student][fields][1]', 'username');
    params.append('populate[student][fields][2]', 'email');
    params.append('populate[exam][fields][0]', 'id');
    params.append('populate[exam][fields][1]', 'title');
    
    const response = await API.get(`/api/exam-attempts?${params.toString()}`);
    return response.data;
  }
};

export default examService;


# Method 1: Using stringData (recommended - auto base64 encodes)
apiVersion: v1
kind: Secret
metadata:
  name: postgres-credentials
  namespace: level2
type: Opaque
stringData:
  username: templeadmin
  password: temple123SecurePassword!
  database: templedb

---
# Method 2: Using data (manual base64 encoding)
apiVersion: v1
kind: Secret
metadata:
  name: api-tokens
  namespace: level2
type: Opaque
data:
  # Encode: echo -n 'value' | base64
  # Decode: echo 'encoded' | base64 -d
  jwt-secret: bXlKd3RTZWNyZXQxMjM0NTY3ODkw  # base64 encoded
  admin-secret: YWRtaW5TZWNyZXQxMjM0NTY3ODkw  # base64 encoded
  api-token-salt: YXBpVG9rZW5TYWx0MTIzNDU2Nzg5MA==  # base64 encoded

---
# TLS Secret (for HTTPS)
apiVersion: v1
kind: Secret
metadata:
  name: tls-secret
  namespace: level2
type: kubernetes.io/tls
stringData:
  tls.crt: |
    -----BEGIN CERTIFICATE-----
    MIICsjCCAZoCCQC... (certificate content)
    -----END CERTIFICATE-----
  tls.key: |
    -----BEGIN PRIVATE KEY-----
    MIIEvQIBADANBgk... (private key content)
    -----END PRIVATE KEY-----

---
# Docker registry secret (for private images)
# kubectl create secret docker-registry regcred \
#   --docker-server=<registry-server> \
#   --docker-username=<username> \
#   --docker-password=<password> \
#   --docker-email=<email> \
#   -n level2

---
# Usage in Deployment:

# 1. Environment variable from Secret:
# env:
# - name: DB_PASSWORD
#   valueFrom:
#     secretKeyRef:
#       name: postgres-credentials
#       key: password

# 2. All keys as environment variables:
# envFrom:
# - secretRef:
#     name: postgres-credentials

# 3. Volume mount (files):
# volumes:
# - name: secrets
#   secret:
#     secretName: postgres-credentials
# volumeMounts:
# - name: secrets
#   mountPath: /etc/secrets
#   readOnly: true

# View secret:
# kubectl get secret postgres-credentials -n level2 -o yaml

# Decode specific key:
# kubectl get secret postgres-credentials -n level2 -o jsonpath='{.data.password}' | base64 -d
